#### map
```
func make(Type, size IntegerType) Type
```
内建函数 make 用来为 slice，map 或 chan 类型分配内存和初始化一个对象(注意：**只能用在这三种类型上**)，跟 new 类似，第一个参数也是一个类型而不是一个值，跟 new 不同的是，make 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型，具体说明如下
```
slice: 第二个参数 size 指定了它的长度，它的容量和长度相同。
你可以传入第三个参数来指定不同的容量值，但必须不能比长度值小。
比如 make([]int, 0, 10)
map: 根据 size 大小来初始化分配内存，不过分配后的 map 长度为 0，如果 size 被忽略了，那么会在初始化分配内存时分配一个小尺寸的内存
channel: 管道缓冲区依据缓冲区容量被初始化。如果容量为 0 或者忽略容量，管道是没有缓冲区的
```
在定义字典时不需要为其指定容量，因为map是可以动态增长的，但是在可以预知map容量的情况下为了提高程序的效率也最好提前标明程序的容量。需要注意的是，不能使用不能比较的元素作为字典的key，例如数组，切片等。而value可以是任意类型的，如果使用interface{}作为value类型，那么就可以接受各种类型的值，只不过在具体使用的时候需要使用类型断言来判断类型

C语言中字符串是通过\0来标识字符串的结束，而go语言中是通过长度来标识字符串是否结束的

#### 字符串
C语言中字符串是通过\0来标识字符串的结束，而go语言中是通过长度来标识字符串是否结束的,想要修改一个字符串的内容，可以将其转换为字节切片，再将其转换为字符串，但是也同样需要重新分配内存

在go语言中字符串都是以utf-8的编码格式进行存储的，所以每个中文占三个字节，所以直接len()含有中文的字符串，得到的是该字符串的字节数。通过 `utf8.RuneCountInString` 函数获得的包含中文的字符串长度则与我们的直觉相符合。而且由于中文对于每个单独的字节来说是不可打印的，所以可以看到很多奇怪的输出，但是将字符串转为rune切片则没有问题

#### 字符串拼接
- s = fmt.Sprintf("%v%v", s, i)
- s += str
- var buf bytes.Buffer -> buf.WriteString(str)
- var builder strings.Builder -> builder.WriteString(str)
其中strings.Builder拼接字符串是最高效的。

#### 基准测试
参考: http://c.biancheng.net/view/124.html

使用如下命令行开启基准测试
```
go test -v -bench=. benchmark_test.go
```
注意：Windows 下使用 go test 命令行时，`-bench=.`应写为`-bench="."`。